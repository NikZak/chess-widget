<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chess Puzzle Widget</title>

    <!-- jQuery (required for Chessboard.js) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- Chessboard.js styles -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
    />

    <!-- Chess logic (Chess.js) and UI (Chessboard.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: #f4f4f4;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .puzzles-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        padding: 20px;
        width: 100%;
        max-width: 1200px;
        box-sizing: border-box;
        margin: 0 auto;
      }

      .widget-container {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        width: 100%;
        max-width: 450px;
        text-align: center;
        box-sizing: border-box;
      }

      .puzzle-instruction {
        font-size: 0.9rem;
        color: #34495e;
        margin-bottom: 10px;
        font-weight: 500;
        min-height: 1.2em;
      }

      #board {
        width: 100%;
        margin: 0 auto 15px auto;
      }

      /* Highlight for checkmated king */
      .square-highlight-checkmate {
        box-shadow: inset 0 0 0 3px #e74c3c !important;
        background-color: rgba(231, 76, 60, 0.3) !important;
      }

      /* Highlight for king in check */
      .square-highlight-check {
        box-shadow: inset 0 0 0 3px #f39c12 !important;
        background-color: rgba(243, 156, 18, 0.3) !important;
      }

      .status-message {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 10px;
        min-height: 1.5em;
      }

      .status-correct {
        color: #27ae60;
      }
      .status-error {
        color: #c0392b;
      }
      .status-neutral {
        color: #2c3e50;
      }
      .status-checkmate {
        color: #e74c3c;
        font-weight: 700;
        animation: pulse 1s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* Responsive design for mobile devices */
      @media (max-width: 480px) {
        .puzzles-container {
          padding: 10px;
          gap: 20px;
        }
        .widget-container {
          padding: 10px;
          box-shadow: none;
          background: transparent;
        }
      }
    </style>
  </head>
  <body>
    <div class="puzzles-container" id="puzzles-container">
      <!-- Puzzles will be dynamically inserted here -->
    </div>

    <script>
      /**
       * TRANSLATIONS
       * Embedded JSON with English and Russian translations
       */
      const translations = {
        en: {
          loading: "Loading puzzle...",
          yourTurn: "Your turn!",
          correct: "Excellent! Wait for response...",
          victory: "Victory! Puzzle solved.",
          wrongMove: "Wrong move. Try again.",
          checkmate: "Checkmate!",
          check: "Check!",
        },
        ru: {
          loading: "Загрузка задачи...",
          yourTurn: "Ваш ход!",
          correct: "Отлично! Ждите ответ...",
          victory: "Победа! Задача решена.",
          wrongMove: "Неверный ход. Попробуйте еще раз.",
          checkmate: "Мат!",
          check: "Шах!",
        },
      };

      /**
       * CONFIGURATION AND STATE
       * Array of puzzle states - each puzzle has its own state
       */
      const Puzzles = []; // Array of puzzle state objects
      let currentLang = "ru"; // Current language (global setting)

      // --- 1. GET DATA FROM URL ---

      const urlParams = new URLSearchParams(window.location.search);

      // Get language from URL parameter (default: 'ru')
      currentLang = urlParams.get("lang") || "ru";
      // Validate language, fallback to 'ru' if invalid
      if (!translations[currentLang]) {
        currentLang = "ru";
      }

      // Translation helper function
      function t(key) {
        return translations[currentLang][key] || key;
      }

      // Default puzzles
      const DEFAULT_PUZZLE_1 = {
        fen: "r3k2r/1b1p1pp1/3qp3/p1bP4/Pp3B2/6P1/1PP1QPB1/R4RK1 b kq - 0 1",
        moves: "d6d5,g2d5,b7d5,a1d1,h8h1",
        message: "Найдите выигрывающую комбинацию",
      };

      const DEFAULT_PUZZLE_2 = {
        fen: "3n3r/2p3k1/1pbbpRpp/6r1/3P4/2PBQ2P/q5P1/5RK1 w - - 0 1",
        moves:
          "e3g5,h6g5,f6g6,g7h7,g6e6,h7g7,e6g6,g7h7,g6d6,h7g7,d6g6,g7h7,g6c6,h7g7,c6g6,g7h7,g6b6,h7g7,b6g6,g7h7,g6a6,h7g7,a6a2",
        message: "Найдите выигрывающую комбинацию",
      };

      const DEFAULT_PUZZLE_3 = {
        fen: "r2q2rk/ppp4p/3p4/2b2Q2/3pPPR1/2P2n2/PP3P1P/RNB4K b - - 0 1",
        moves: "d8h4,g4h4,g8g1",
        message: "Найдите выигрывающий ход",
      };

      // Parse puzzles from URL
      // Format: ?puzzles=fen1|moves1|message1;fen2|moves2|message2
      // Or use legacy format: ?fen=...&moves=...&message=...
      let puzzlesData = [];

      const puzzlesParam = urlParams.get("puzzles");
      const fenParam = urlParams.get("fen");
      const movesParam = urlParams.get("moves");

      // Check if any puzzle parameters are provided
      const hasPuzzleParams = puzzlesParam || fenParam || movesParam;

      if (puzzlesParam) {
        // New format: multiple puzzles separated by ;
        const puzzleStrings = puzzlesParam.split(";");
        puzzlesData = puzzleStrings.map((puzzleStr) => {
          const parts = puzzleStr.split("|");
          return {
            fen: decodeURIComponent(parts[0] || DEFAULT_PUZZLE_1.fen),
            moves: decodeURIComponent(parts[1] || DEFAULT_PUZZLE_1.moves),
            message: decodeURIComponent(parts[2] || ""),
          };
        });
      } else if (fenParam || movesParam) {
        // Legacy format: single puzzle
        const messageParam =
          urlParams.get("message") || DEFAULT_PUZZLE_1.message;
        puzzlesData = [
          {
            fen: fenParam || DEFAULT_PUZZLE_1.fen,
            moves: movesParam || DEFAULT_PUZZLE_1.moves,
            message: messageParam,
          },
        ];
      } else {
        // No parameters: use 3 default puzzles
        puzzlesData = [DEFAULT_PUZZLE_1, DEFAULT_PUZZLE_2, DEFAULT_PUZZLE_3];
      }

      // --- 2. INITIALIZATION ---

      $(document).ready(function () {
        initPuzzles();
      });

      // Function to notify parent window of content height (for iframe auto-resize)
      function notifyHeight() {
        const height = document.body.scrollHeight;
        window.parent.postMessage(
          {
            type: "CHESS_PUZZLE_HEIGHT",
            height: height,
          },
          "*"
        );
      }

      function initPuzzles() {
        const container = $("#puzzles-container");
        container.empty();

        puzzlesData.forEach((puzzleData, index) => {
          // Create puzzle container
          const puzzleId = `puzzle-${index}`;
          const puzzleHtml = `
            <div class="widget-container" id="${puzzleId}-container">
              <div class="puzzle-instruction" id="${puzzleId}-instruction">${
            puzzleData.message || ""
          }</div>
              <div id="${puzzleId}-status" class="status-message status-neutral">${t(
            "loading"
          )}</div>
              <div id="${puzzleId}-board"></div>
            </div>
          `;
          container.append(puzzleHtml);

          // Parse moves string into array
          const solution = puzzleData.moves.split(",").map((m) => m.trim());

          // Determine player color from FEN
          const tempGame = new Chess(puzzleData.fen);
          const orientation = tempGame.turn() === "w" ? "white" : "black";

          // Create puzzle state
          const puzzleState = {
            id: puzzleId,
            game: new Chess(puzzleData.fen),
            board: null,
            solution: solution,
            currentMoveIdx: 0,
            isPlayerTurn: true,
            orientation: orientation,
            fen: puzzleData.fen,
            message: puzzleData.message || "",
          };

          Puzzles.push(puzzleState);

          // Initialize board
          const config = {
            draggable: true,
            position: puzzleData.fen,
            orientation: orientation,
            onDragStart: function (source, piece) {
              return onDragStart(index, source, piece);
            },
            onDrop: function (source, target) {
              return onDrop(index, source, target);
            },
            onSnapEnd: function () {
              onSnapEnd(index);
            },
            pieceTheme:
              "https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png",
          };

          puzzleState.board = Chessboard(`${puzzleId}-board`, config);

          // Small delay to show loading, then show "Your turn"
          setTimeout(() => {
            updateStatus(index, t("yourTurn"));
            // Notify parent of height after all puzzles are initialized
            if (index === puzzlesData.length - 1) {
              setTimeout(notifyHeight, 500);
            }
          }, 300 + index * 100); // Stagger initialization slightly
        });

        // Also notify height after a short delay to ensure boards are rendered
        setTimeout(notifyHeight, 1000);
      }

      // --- 3. INTERACTION LOGIC ---

      function onDragStart(puzzleIndex, source, piece) {
        const state = Puzzles[puzzleIndex];
        // Prevent dragging pieces if game is over or not player's turn
        if (state.game.game_over() || !state.isPlayerTurn) return false;

        // Only allow dragging own pieces
        if (
          (state.game.turn() === "w" && piece.search(/^b/) !== -1) ||
          (state.game.turn() === "b" && piece.search(/^w/) !== -1)
        ) {
          return false;
        }
      }

      function onDrop(puzzleIndex, source, target) {
        const state = Puzzles[puzzleIndex];
        // Clear any existing highlights when starting a new move
        clearHighlights(puzzleIndex);

        // 1. Check move legality according to chess rules
        const moveObj = {
          from: source,
          to: target,
          promotion: "q", // Always promote to queen for simplicity
        };

        const move = state.game.move(moveObj);

        // If move is illegal -> return piece back
        if (move === null) return "snapback";

        // 2. Check if move matches puzzle solution
        const userMoveString = source + target;
        const correctMoveString = state.solution[state.currentMoveIdx];

        if (userMoveString === correctMoveString) {
          // -- CORRECT MOVE --
          state.currentMoveIdx++;

          // Check for checkmate first (checkmate is a subset of check)
          if (state.game.in_checkmate()) {
            // Highlight the king's square (opponent is in checkmate, so use current turn color)
            const kingSquare = getKingSquare(puzzleIndex, state.game.turn());
            if (kingSquare) {
              highlightSquare(puzzleIndex, kingSquare);
            }

            // Check if puzzle is complete
            if (state.currentMoveIdx >= state.solution.length) {
              updateStatus(
                puzzleIndex,
                t("checkmate") + " " + t("victory"),
                "checkmate"
              );
              state.board.position(state.game.fen());
              notifyParentSuccess(puzzleIndex); // Notify parent page
              return;
            } else {
              // Checkmate but puzzle continues (shouldn't happen, but handle it)
              updateStatus(
                puzzleIndex,
                t("checkmate") + "! " + t("correct"),
                "checkmate"
              );
              state.isPlayerTurn = false;
              window.setTimeout(() => makeOpponentMove(puzzleIndex), 500);
              return;
            }
          }

          // Check for check (but not checkmate)
          if (state.game.in_check()) {
            // Highlight the king's square (opponent is in check, so use current turn color)
            const kingSquare = getKingSquare(puzzleIndex, state.game.turn());
            if (kingSquare) {
              highlightCheck(puzzleIndex, kingSquare);
            }
          }

          // Check if puzzle is complete
          if (state.currentMoveIdx >= state.solution.length) {
            updateStatus(puzzleIndex, t("victory"), "correct");
            state.board.position(state.game.fen());
            notifyParentSuccess(puzzleIndex); // Notify parent page
            return;
          }

          // If puzzle not complete, pass turn to computer
          // Show check message if in check
          const statusMessage = state.game.in_check()
            ? t("check") + "! " + t("correct")
            : t("correct");
          updateStatus(puzzleIndex, statusMessage, "correct");
          state.isPlayerTurn = false;

          // Make opponent move with small delay for realism
          window.setTimeout(() => makeOpponentMove(puzzleIndex), 500);
        } else {
          // -- WRONG MOVE --
          updateStatus(puzzleIndex, t("wrongMove"), "error");
          state.game.undo(); // Undo move in logic
          return "snapback"; // Return piece visually
        }
      }

      // Function for automatic opponent move
      function makeOpponentMove(puzzleIndex) {
        const state = Puzzles[puzzleIndex];
        const opponentMoveString = state.solution[state.currentMoveIdx];

        // Convert string "e2e4" to object {from: 'e2', to: 'e4'}
        const fromSq = opponentMoveString.substring(0, 2);
        const toSq = opponentMoveString.substring(2, 4);

        state.game.move({ from: fromSq, to: toSq, promotion: "q" });
        state.board.position(state.game.fen());

        // Check for checkmate after opponent's move
        if (state.game.in_checkmate()) {
          // Highlight the king's square (player is in checkmate, so use current turn color)
          const kingSquare = getKingSquare(puzzleIndex, state.game.turn());
          if (kingSquare) {
            highlightSquare(puzzleIndex, kingSquare);
          }

          state.currentMoveIdx++;

          // Check if puzzle is complete
          if (state.currentMoveIdx >= state.solution.length) {
            updateStatus(
              puzzleIndex,
              t("checkmate") + "! " + t("victory"),
              "checkmate"
            );
            notifyParentSuccess(puzzleIndex); // Notify parent page
            return;
          } else {
            // Checkmate but puzzle continues (shouldn't happen, but handle it)
            updateStatus(
              puzzleIndex,
              t("checkmate") + "! " + t("yourTurn"),
              "checkmate"
            );
            state.isPlayerTurn = true;
            return;
          }
        }

        // Check for check after opponent's move (but not checkmate)
        if (state.game.in_check()) {
          // Highlight the king's square (player is in check, so use current turn color)
          const kingSquare = getKingSquare(puzzleIndex, state.game.turn());
          if (kingSquare) {
            highlightCheck(puzzleIndex, kingSquare);
          }
        }

        state.currentMoveIdx++;
        state.isPlayerTurn = true;
        // Show check message if in check
        const statusMessage = state.game.in_check()
          ? t("check") + "! " + t("yourTurn")
          : t("yourTurn");
        updateStatus(puzzleIndex, statusMessage);
      }

      // Helper function to highlight a square on the board (for checkmate)
      function highlightSquare(puzzleIndex, square) {
        const state = Puzzles[puzzleIndex];
        // Remove existing highlights
        clearHighlights(puzzleIndex);
        // Add checkmate highlight to the target square
        $(`#${state.id}-board .square-${square}`).addClass(
          "square-highlight-checkmate"
        );
      }

      // Helper function to highlight a square for check
      function highlightCheck(puzzleIndex, square) {
        const state = Puzzles[puzzleIndex];
        // Remove existing highlights
        clearHighlights(puzzleIndex);
        // Add check highlight to the target square
        $(`#${state.id}-board .square-${square}`).addClass(
          "square-highlight-check"
        );
      }

      // Helper function to remove all highlights
      function clearHighlights(puzzleIndex) {
        const state = Puzzles[puzzleIndex];
        $(`#${state.id}-board .square-55d63`).removeClass(
          "square-highlight-checkmate square-highlight-check"
        );
      }

      // Helper function to find the king's square for a given color
      function getKingSquare(puzzleIndex, color) {
        const state = Puzzles[puzzleIndex];
        const board = state.game.board();
        const kingPiece = color === "w" ? "K" : "k";

        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (
              board[i][j] &&
              board[i][j].type === "k" &&
              board[i][j].color === color
            ) {
              // Convert array indices to square notation (a1-h8)
              const file = String.fromCharCode(97 + j); // a-h
              const rank = 8 - i; // 1-8
              return file + rank;
            }
          }
        }
        return null;
      }

      // Update board position after animation (castling, etc.)
      function onSnapEnd(puzzleIndex) {
        const state = Puzzles[puzzleIndex];
        state.board.position(state.game.fen());
      }

      // Helper function to update status text
      function updateStatus(puzzleIndex, text, type = "neutral") {
        const state = Puzzles[puzzleIndex];
        const $status = $(`#${state.id}-status`);
        $status
          .text(text)
          .removeClass(
            "status-correct status-error status-neutral status-checkmate"
          );

        if (type === "correct") $status.addClass("status-correct");
        else if (type === "error") $status.addClass("status-error");
        else if (type === "checkmate") $status.addClass("status-checkmate");
        else $status.addClass("status-neutral");
      }

      // --- 4. PARENT WINDOW COMMUNICATION ---

      function notifyParentSuccess(puzzleIndex) {
        const state = Puzzles[puzzleIndex];
        // Send message to parent window (site where widget is embedded)
        window.parent.postMessage(
          {
            type: "CHESS_PUZZLE_SOLVED",
            puzzleIndex: puzzleIndex,
            fen: state.game.fen(),
            solved: true,
          },
          "*"
        );
      }
    </script>
  </body>
</html>
